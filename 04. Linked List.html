1. 링크드 리스트(Linked List)

2. 특징

    데이터를 관리하고 저장하는 자료구조 중 하나로 순차적으로 저장된 노드(Node)의 포인터(Poniter)로
    다음 노드를 연결해 순차적인 데이터를 관리하는 자료구조

    노드(Node) : 데이터의 저장 단위 및 저장 공간
    포인터(Pointer) : 각 노드의 이전이나 다음 연결 정보(노드 정보)를 가지고 있는 공간

    장점: 미리 데이터를 할당하지 않아도 필요에 따라 늘리고 연결 할 수 있음.
    단점: 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느리고, 중간 데이터를 삭제하거나 수정 시 데이터 연결을
          재구성해야 하는 번거로움이 있음.

3. 소스(파이썬)


    3-1. 클래스를 활용
        class Node:
            def __init__(self, next=None):
                self.data = data
                self.next = next

        node1 = Node(1)
        node2 = Node2(2)
        node1.next = node2
        head = node1

        * self는 Java에서 this같은 역할
          head는 첫번째 노드를 저장(시작점)


    3-2. 링크드 리스트 데이터 추가 및 출력

    class Node:
        def __init__(self,data, next=None):
            self.data = data
            self.next = next

    def add(data):
        node = head
        while node.next:
            node = node.next
        node.next = Node(data)


    ---------------입력----------------

    node1 = Node(1)
    head = node1
    for index in range(2, 10):
        add(index)

    * 2 ~ 9까지 add

    ----------------출력----------------
ㅑ
    node = head
    while node.next:
        print(node.data)
        node = node.next
    print (node.data)

    1
    2
    3
    4
    5
    .
    .
    .

    * node에 next(pinter)가 있으면 현재 노드를 출력하고
      다음 노드주소를 넘겨준다. 만약 포인터 정보가 없으면 현재 노드를 출력하고 종료
      파이썬에서 __init__ 은 자바에서 생성자와 비슷

    3-3. 중간 노드 데이터 변경 하기

    node3 = Node(1.5)
    ----------------------------
    node = head
    search = True
    while search:
        if node.data == 1:
            search = False
        else:
            node = node.next
    pre_node_next = node.next
    node.next     = node3
    node3.next     = node_next

    * search를 이용해 새 노드의 이전 노드를 찾고
      새로 들어갈 노드의 포인터 이전 노드에서 가져온
       다음 노드의 포인터 주소를 저장



    3-4. 노드의 삭제하기

        1. head 삭제
        2. 마지막 노드 삭제
        3. 중간 노드 삭제


        def delete(self, data):
            if self.hrad == "";
                print("해당 값을 가진 노드가 없습니다.")
                return

            if(self.head.data == data):  <- 1번 케이스
                temp = self.head
                self.head = self.head.next
                del temp
            else:                        <- 2,3번 케이스
                node = self.head
                while node.next:
                    if node.next.data == data:     <- del target Node true
                        temp = node.next
                        node.next = node.next.next <- del target Node Next Pointer
                        del temp
                    else:                          <- del target Node False
                        node = node.next

